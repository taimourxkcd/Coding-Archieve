int *a 				: a is pointer to the variable int 
char *a 			: a is pointer to the variable char and same for all others

			***************E1******************
int a = 1025
int *p = a;

printf(*p)		    // 1025					//int  	4 bytes char 1 byte 
									//float 4 bytes
char *p0;								
*p0 = (char *)p;
prinf(p0)		// becase char is 1 byte 
 			
			*****************E2************************

int a = 1025
int *p = a;

printf(*p)		    // 1025					
									
// void pointer - generic pointer 
void *p0;
p0 = p;		// NOTICE THAT WE WILL NOT GET ANY ERROR HERE NO TYPE CASTING IS REQUIRED 

prinf(p0);  
prinf(*p0); // can not dereference, will get an error here
prinf(p0+); // not possible

		*******************POINTER TO POINTER*****************************************

int x = 5
int *p = &x			// q =215, p=225, x=6, r = 215  r -> q -> p -> x
*p = 6;
int** q = &p;     
int*** r = &q
printf(*p)      // 6
printf(*q)	//225
printf(**q)	//6
printf(**r)	//225
printf(***r)	//6		// BONUS POINT: when a function is called from the main and a variable is passed in its parameter. its argument is called "actual argument"
				//		however in case of the called function outside the main function, it is called formal argument 
***r = 10			
print(x)  	//10
**q = *p +2 
print(x)    	//12
			*****************************************POINTERS AND ARRAYS**************************************************************

NOTE				

Address	: &A[i]  OR (A+i)  // both mean the same thing 
Value	: A[i] 	 OR *(A+i)  // both mean the same thing also here

int a[] = {1,2,3,4,5}
printf(a)	 // 1023432344 
printf(&a[0])	 // 1023432344	
printf(a[0])	 //  1 
printf(*a)	 //  1

int *p = a;
a++		// invalud
p++		// valid

			*************************************************ARRAYS AS FUNCTION ARGUMENTS*****************************************************
NOTE: 					* when an array is passed as a parameter in a function, when it reaches the function its size changes			
					   eg A[] ={1,2,3,4,5}  in MAIN is 20 bytes however in case of function it is 4 bytes  
					THIS HAPPENS BECAUSE 
							    the compiler implicitly converts that local variable in the function to a pointer that points to the varibale that is passed from the MAIN
					*Arrays are always(should be) passed by reference because sometimes arrays can be very large and it makes no sense to make the copy of same array to waste space 
					 
                     *************************************************CHARACTER ARRAYS AND POINTERS*****************************************************
*	In order to indicate the end of a character string we use the null character(\0) to indicate the end
	eg "John" has size >= 5 
* 	NOTE that when we use the strlen() function it calculates till the null character eg "John" size is 4
*	NULL termination is implicit(done automaticallly by the compiler) eg char[] = "JOHN"
	HOWEVER in this case: char[5] = {'J','O','H','N','\0'}, we have to explicitly state the null termination 


*	STACK memory increases from the buttom to the top
	any function called is placed in the stack above the MAIN function 

		*************************************************CHARACTER ARRAYS AND POINTERS*****************************************************
	 
* NOTE: 			:*(A+i) is the same as A[i]
				  (A+i) is the same as &A[i]
* int B[2][3]
  when we say int *p = B; ERROR 	// because B will return a pointer to the 1-D array of three integers 
 
  
		*************************************************MULTI DIMENTSIONAL ARRAYS AND POINTERS*****************************************************
   int *p[3] = B; 			// valid   // declaring pointer to a 1-D array of 3 integers  

  *B[i][j] = *(*B[i] + j) = *( *(B+i) + j) // all of these expressions are the same 

  *B[2][3]	: it means that B is a two dimensional array with 3 elements each and 24 bytes(1 byte each)

# A three dimensional array is just the collection of two 2-D arrays

int C[3][2][2]  : 

int (*p)[2][2] = C

#			:C[i][j][k] = *(C[i][j]+k) = *(*(C[i] + j) + k) = *(*(*(c+i)+j) + k)   // all of these are the same 

		************************************************* POINTERS AND DYNAMIC MEMORY  *****************************************************

# stack size can not vary 
# heap can grow as long as you want until you have enough memory 
# heap is dynamic memory 
# heap and heap data structure is not the similar thing however stack is actually the implementation of the data structue stack

# You can not dereferene a void pointer, it is a generic pointer 
# malloc does not care if you allocate memory to an int , char or whatever , so it return a void pointer 
	SOLUTION: 
		you can type cast like this: int *p = (int*)malloc(3*sizeof(int))
						*p = 10; //valid 
						*(p+1) = 4 //next element in the heap allocated array 
						*(p+2) = 6 //next element in the heap allocated array 
# All memory allocation in happens through pointers


#CALLOC
		you can type cast like this: int *p = (int*)calloc(3, sizeof(int))

# one difference between calloc and malloc is that malloc does the initialization and initializes everything to zero however malloc initializes to some garbage value

		

#REALLOC	

		
	
	************************************************FUNCTION and POINTERS**********************************************************

Use Cases:
	 #1 function pointers can be passed as arguments to the functions THIS IS CALLED CALL BACK FUNCTION  

           *******************************************MEMORY LEAKSK********************************************************************


  





























